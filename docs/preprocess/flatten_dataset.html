<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>jidenn.preprocess.flatten_dataset API documentation</title>
<meta name="description" content="Set of functions to flatten a dataset. The flattening is done by the reference variable, which is assumed to be a
tf.RaggedTensor. The shape of the â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="canonical" href="http://jansam.wieno.sk/JIDENN/jidenn/preprocess/flatten_dataset.html">
<link rel="icon" href="images/q_g_tagging.jpeg">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>jidenn.preprocess.flatten_dataset</code></h1>
</header>
<section id="section-intro">
<p>Set of functions to flatten a dataset. The flattening is done by the reference variable, which is assumed to be a
tf.RaggedTensor. The shape of the reference variable is used to infer the shape of the other variables. Th</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Set of functions to flatten a dataset. The flattening is done by the reference variable, which is assumed to be a
tf.RaggedTensor. The shape of the reference variable is used to infer the shape of the other variables. Th

&#34;&#34;&#34;
import tensorflow as tf
from typing import Tuple, List, Dict, Union, Optional, Callable

ROOTVariables = Dict[str, tf.RaggedTensor]


def get_ragged_to_dataset_fn(reference_variable: str = &#39;jets_PartonTruthLabelID&#39;) -&gt; Callable[[ROOTVariables], tf.data.Dataset]:
    &#34;&#34;&#34;Get a function that converts a tf.RaggedTensor to a tf.data.Dataset. The intended use is to use this function 
    in a tf.data.Dataset.interleave call to flatten a dataset. The function will infer the shape of the ragged tensor
    from the shape of the reference variable. Variables toher than the reference variable will be tiled to match the
    shape of the reference variable (they will be duplicated).

    Args:
        reference_variable (str, optional): The variable to use as reference for infering the shape of
            variables to flatten. Defaults to &#39;jets_PartonTruthLabelID&#39;.

    Returns:
        Callable[[ROOTVariables], tf.data.Dataset]: A function that converts a tf.RaggedTensor to a tf.data.Dataset
    &#34;&#34;&#34;
    @tf.function
    def _ragged_to_dataset(sample: ROOTVariables) -&gt; tf.data.Dataset:
        sample = sample.copy()
        ragged_shape = tf.shape(sample[reference_variable])
        for key, item in sample.items():
            if isinstance(item, tf.RaggedTensor) and ragged_shape[0] == tf.shape(item)[0]:
                continue
            elif len(tf.shape(item)) == 0:
                sample[key] = tf.tile(item[tf.newaxis, tf.newaxis], [ragged_shape[0], 1])
            elif tf.shape(item)[0] != ragged_shape[0]:
                sample[key] = tf.tile(item[tf.newaxis, :], [ragged_shape[0], 1])
            else:
                continue
        return tf.data.Dataset.from_tensor_slices(sample)
    return _ragged_to_dataset


def get_filter_empty_fn(reference_variable: str = &#39;jets_PartonTruthLabelID&#39;) -&gt; Callable[[ROOTVariables], tf.Tensor]:
    &#34;&#34;&#34;Get a function that filters out empty RaggedTensors from a ROOTVariables dictionary. The intended use is to use
    this function in a tf.data.Dataset.filter call to filter out empty events.

    Args:
        reference_variable (str, optional): The variable to use as reference for infering the shape of
            empty events. Defaults to &#39;jets_PartonTruthLabelID&#39;.

    Returns:
        Callable[[ROOTVariables], tf.Tensor]: A function that filters out empty RaggedTensors from a ROOTVariables
    &#34;&#34;&#34;
    @tf.function
    def _filter_empty(sample: ROOTVariables) -&gt; tf.Tensor:
        return tf.greater(tf.size(sample[reference_variable]), 0)
    return _filter_empty


def get_filter_ragged_values_fn(reference_variable: str = &#39;jets_PartonTruthLabelID&#39;,
                                         wanted_values: List[int] = [1, 2, 3, 4, 5, 6, 21]) -&gt; Callable[[ROOTVariables], ROOTVariables]:
    &#34;&#34;&#34;Get a function that filters out unwanted values from a ROOTVariables dictionary containg a RaggedTensor. The
    intended use is to use this function in a tf.data.Dataset.map call to filter out unwanted values from a dataset.
    the `get_filter_empty_fn` function should be used after this function to filter out empty events.

    Args:
        reference_variable (str, optional): The variable whose values to filter. Defaults to &#39;jets_PartonTruthLabelID&#39;.
        wanted_values (List[int], optional): The values to keep. Defaults to [1, 2, 3, 4, 5, 6, 21].

    Returns:
        Callable[[ROOTVariables], ROOTVariables]: A function that filters out unwanted values from a ROOTVariables
    &#34;&#34;&#34;
    @tf.function
    def _filter_unwanted_ragged_values_fn(sample: ROOTVariables) -&gt; ROOTVariables:
        sample = sample.copy()
        mask = tf.math.reduce_any(tf.math.equal(sample[reference_variable], wanted_values), axis=-1)
        for key, item in sample.items():
            if tf.reduce_all(tf.math.equal(tf.shape(item), tf.shape(mask))):
                sample[key] = tf.ragged.boolean_mask(item, mask)
        return sample
    return _filter_unwanted_ragged_values_fn


def flatten_dataset(dataset: tf.data.Dataset,
                    reference_variable: str = &#39;jets_PartonTruthLabelID&#39;,
                    wanted_values: Optional[List[int]] = None) -&gt; tf.data.Dataset:
    &#34;&#34;&#34;Apply a series of transformations to a tf.data.Dataset to flatten it. The flattening is done by the reference
    variable, which is assumed to be a tf.RaggedTensor. The shape of the reference variable is used to infer the shape
    of the other variables. The other variables are tiled to match the shape of the reference variable. The dataset is
    then filtered to remove empty events. If wanted_values is not None, the reference variable is filtered to only
    contain the wanted values.

    Args:
        dataset (tf.data.Dataset): The dataset to flatten.
        reference_variable (str, optional): The variable to use as reference for infering the shape of
            variables to flatten. Defaults to &#39;jets_PartonTruthLabelID&#39;.
        wanted_values (Optional[List[int]], optional): The values to keep in the reference variable. Defaults to None.

    Returns:
        tf.data.Dataset: The flattened dataset
    &#34;&#34;&#34;

    if wanted_values is None:
        return (
            dataset
            .map(get_filter_empty_fn(reference_variable))
            .interleave(get_ragged_to_dataset_fn(reference_variable))
        )
    else:
        return (
            dataset
            .map(get_filter_ragged_values_fn(reference_variable, wanted_values))
            .map(get_filter_empty_fn(reference_variable))
            .interleave(get_ragged_to_dataset_fn(reference_variable))
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="jidenn.preprocess.flatten_dataset.flatten_dataset"><code class="name flex">
<span>def <span class="ident">flatten_dataset</span></span>(<span>dataset:Â tensorflow.python.data.ops.dataset_ops.DatasetV2, reference_variable:Â strÂ =Â 'jets_PartonTruthLabelID', wanted_values:Â Optional[List[int]]Â =Â None) â€‘>Â tensorflow.python.data.ops.dataset_ops.DatasetV2</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a series of transformations to a tf.data.Dataset to flatten it. The flattening is done by the reference
variable, which is assumed to be a tf.RaggedTensor. The shape of the reference variable is used to infer the shape
of the other variables. The other variables are tiled to match the shape of the reference variable. The dataset is
then filtered to remove empty events. If wanted_values is not None, the reference variable is filtered to only
contain the wanted values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataset</code></strong> :&ensp;<code>tf.data.Dataset</code></dt>
<dd>The dataset to flatten.</dd>
<dt><strong><code>reference_variable</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The variable to use as reference for infering the shape of
variables to flatten. Defaults to 'jets_PartonTruthLabelID'.</dd>
<dt><strong><code>wanted_values</code></strong> :&ensp;<code>Optional[List[int]]</code>, optional</dt>
<dd>The values to keep in the reference variable. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tf.data.Dataset</code></dt>
<dd>The flattened dataset</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten_dataset(dataset: tf.data.Dataset,
                    reference_variable: str = &#39;jets_PartonTruthLabelID&#39;,
                    wanted_values: Optional[List[int]] = None) -&gt; tf.data.Dataset:
    &#34;&#34;&#34;Apply a series of transformations to a tf.data.Dataset to flatten it. The flattening is done by the reference
    variable, which is assumed to be a tf.RaggedTensor. The shape of the reference variable is used to infer the shape
    of the other variables. The other variables are tiled to match the shape of the reference variable. The dataset is
    then filtered to remove empty events. If wanted_values is not None, the reference variable is filtered to only
    contain the wanted values.

    Args:
        dataset (tf.data.Dataset): The dataset to flatten.
        reference_variable (str, optional): The variable to use as reference for infering the shape of
            variables to flatten. Defaults to &#39;jets_PartonTruthLabelID&#39;.
        wanted_values (Optional[List[int]], optional): The values to keep in the reference variable. Defaults to None.

    Returns:
        tf.data.Dataset: The flattened dataset
    &#34;&#34;&#34;

    if wanted_values is None:
        return (
            dataset
            .map(get_filter_empty_fn(reference_variable))
            .interleave(get_ragged_to_dataset_fn(reference_variable))
        )
    else:
        return (
            dataset
            .map(get_filter_ragged_values_fn(reference_variable, wanted_values))
            .map(get_filter_empty_fn(reference_variable))
            .interleave(get_ragged_to_dataset_fn(reference_variable))
        )</code></pre>
</details>
</dd>
<dt id="jidenn.preprocess.flatten_dataset.get_filter_empty_fn"><code class="name flex">
<span>def <span class="ident">get_filter_empty_fn</span></span>(<span>reference_variable:Â strÂ =Â 'jets_PartonTruthLabelID') â€‘>Â Callable[[Dict[str,Â tensorflow.python.ops.ragged.ragged_tensor.RaggedTensor]],Â tensorflow.python.framework.ops.Tensor]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a function that filters out empty RaggedTensors from a ROOTVariables dictionary. The intended use is to use
this function in a tf.data.Dataset.filter call to filter out empty events.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reference_variable</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The variable to use as reference for infering the shape of
empty events. Defaults to 'jets_PartonTruthLabelID'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable[[ROOTVariables], tf.Tensor]</code></dt>
<dd>A function that filters out empty RaggedTensors from a ROOTVariables</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_filter_empty_fn(reference_variable: str = &#39;jets_PartonTruthLabelID&#39;) -&gt; Callable[[ROOTVariables], tf.Tensor]:
    &#34;&#34;&#34;Get a function that filters out empty RaggedTensors from a ROOTVariables dictionary. The intended use is to use
    this function in a tf.data.Dataset.filter call to filter out empty events.

    Args:
        reference_variable (str, optional): The variable to use as reference for infering the shape of
            empty events. Defaults to &#39;jets_PartonTruthLabelID&#39;.

    Returns:
        Callable[[ROOTVariables], tf.Tensor]: A function that filters out empty RaggedTensors from a ROOTVariables
    &#34;&#34;&#34;
    @tf.function
    def _filter_empty(sample: ROOTVariables) -&gt; tf.Tensor:
        return tf.greater(tf.size(sample[reference_variable]), 0)
    return _filter_empty</code></pre>
</details>
</dd>
<dt id="jidenn.preprocess.flatten_dataset.get_filter_ragged_values_fn"><code class="name flex">
<span>def <span class="ident">get_filter_ragged_values_fn</span></span>(<span>reference_variable:Â strÂ =Â 'jets_PartonTruthLabelID', wanted_values:Â List[int]Â =Â [1, 2, 3, 4, 5, 6, 21]) â€‘>Â Callable[[Dict[str,Â tensorflow.python.ops.ragged.ragged_tensor.RaggedTensor]],Â Dict[str,Â tensorflow.python.ops.ragged.ragged_tensor.RaggedTensor]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a function that filters out unwanted values from a ROOTVariables dictionary containg a RaggedTensor. The
intended use is to use this function in a tf.data.Dataset.map call to filter out unwanted values from a dataset.
the <code><a title="jidenn.preprocess.flatten_dataset.get_filter_empty_fn" href="#jidenn.preprocess.flatten_dataset.get_filter_empty_fn">get_filter_empty_fn()</a></code> function should be used after this function to filter out empty events.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reference_variable</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The variable whose values to filter. Defaults to 'jets_PartonTruthLabelID'.</dd>
<dt><strong><code>wanted_values</code></strong> :&ensp;<code>List[int]</code>, optional</dt>
<dd>The values to keep. Defaults to [1, 2, 3, 4, 5, 6, 21].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable[[ROOTVariables], ROOTVariables]</code></dt>
<dd>A function that filters out unwanted values from a ROOTVariables</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_filter_ragged_values_fn(reference_variable: str = &#39;jets_PartonTruthLabelID&#39;,
                                         wanted_values: List[int] = [1, 2, 3, 4, 5, 6, 21]) -&gt; Callable[[ROOTVariables], ROOTVariables]:
    &#34;&#34;&#34;Get a function that filters out unwanted values from a ROOTVariables dictionary containg a RaggedTensor. The
    intended use is to use this function in a tf.data.Dataset.map call to filter out unwanted values from a dataset.
    the `get_filter_empty_fn` function should be used after this function to filter out empty events.

    Args:
        reference_variable (str, optional): The variable whose values to filter. Defaults to &#39;jets_PartonTruthLabelID&#39;.
        wanted_values (List[int], optional): The values to keep. Defaults to [1, 2, 3, 4, 5, 6, 21].

    Returns:
        Callable[[ROOTVariables], ROOTVariables]: A function that filters out unwanted values from a ROOTVariables
    &#34;&#34;&#34;
    @tf.function
    def _filter_unwanted_ragged_values_fn(sample: ROOTVariables) -&gt; ROOTVariables:
        sample = sample.copy()
        mask = tf.math.reduce_any(tf.math.equal(sample[reference_variable], wanted_values), axis=-1)
        for key, item in sample.items():
            if tf.reduce_all(tf.math.equal(tf.shape(item), tf.shape(mask))):
                sample[key] = tf.ragged.boolean_mask(item, mask)
        return sample
    return _filter_unwanted_ragged_values_fn</code></pre>
</details>
</dd>
<dt id="jidenn.preprocess.flatten_dataset.get_ragged_to_dataset_fn"><code class="name flex">
<span>def <span class="ident">get_ragged_to_dataset_fn</span></span>(<span>reference_variable:Â strÂ =Â 'jets_PartonTruthLabelID') â€‘>Â Callable[[Dict[str,Â tensorflow.python.ops.ragged.ragged_tensor.RaggedTensor]],Â tensorflow.python.data.ops.dataset_ops.DatasetV2]</span>
</code></dt>
<dd>
<div class="desc"><p>Get a function that converts a tf.RaggedTensor to a tf.data.Dataset. The intended use is to use this function
in a tf.data.Dataset.interleave call to flatten a dataset. The function will infer the shape of the ragged tensor
from the shape of the reference variable. Variables toher than the reference variable will be tiled to match the
shape of the reference variable (they will be duplicated).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reference_variable</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The variable to use as reference for infering the shape of
variables to flatten. Defaults to 'jets_PartonTruthLabelID'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable[[ROOTVariables], tf.data.Dataset]</code></dt>
<dd>A function that converts a tf.RaggedTensor to a tf.data.Dataset</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ragged_to_dataset_fn(reference_variable: str = &#39;jets_PartonTruthLabelID&#39;) -&gt; Callable[[ROOTVariables], tf.data.Dataset]:
    &#34;&#34;&#34;Get a function that converts a tf.RaggedTensor to a tf.data.Dataset. The intended use is to use this function 
    in a tf.data.Dataset.interleave call to flatten a dataset. The function will infer the shape of the ragged tensor
    from the shape of the reference variable. Variables toher than the reference variable will be tiled to match the
    shape of the reference variable (they will be duplicated).

    Args:
        reference_variable (str, optional): The variable to use as reference for infering the shape of
            variables to flatten. Defaults to &#39;jets_PartonTruthLabelID&#39;.

    Returns:
        Callable[[ROOTVariables], tf.data.Dataset]: A function that converts a tf.RaggedTensor to a tf.data.Dataset
    &#34;&#34;&#34;
    @tf.function
    def _ragged_to_dataset(sample: ROOTVariables) -&gt; tf.data.Dataset:
        sample = sample.copy()
        ragged_shape = tf.shape(sample[reference_variable])
        for key, item in sample.items():
            if isinstance(item, tf.RaggedTensor) and ragged_shape[0] == tf.shape(item)[0]:
                continue
            elif len(tf.shape(item)) == 0:
                sample[key] = tf.tile(item[tf.newaxis, tf.newaxis], [ragged_shape[0], 1])
            elif tf.shape(item)[0] != ragged_shape[0]:
                sample[key] = tf.tile(item[tf.newaxis, :], [ragged_shape[0], 1])
            else:
                continue
        return tf.data.Dataset.from_tensor_slices(sample)
    return _ragged_to_dataset</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="JIDENN" href="https://jansam.wieno.sk/JIDENN/">
<img src="images/q_g_tagging.jpeg" alt=""> JIDENN
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="jidenn.preprocess" href="index.html">jidenn.preprocess</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="jidenn.preprocess.flatten_dataset.flatten_dataset" href="#jidenn.preprocess.flatten_dataset.flatten_dataset">flatten_dataset</a></code></li>
<li><code><a title="jidenn.preprocess.flatten_dataset.get_filter_empty_fn" href="#jidenn.preprocess.flatten_dataset.get_filter_empty_fn">get_filter_empty_fn</a></code></li>
<li><code><a title="jidenn.preprocess.flatten_dataset.get_filter_ragged_values_fn" href="#jidenn.preprocess.flatten_dataset.get_filter_ragged_values_fn">get_filter_ragged_values_fn</a></code></li>
<li><code><a title="jidenn.preprocess.flatten_dataset.get_ragged_to_dataset_fn" href="#jidenn.preprocess.flatten_dataset.get_ragged_to_dataset_fn">get_ragged_to_dataset_fn</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>